#include <iostream>#include <vector>#include <map>#include <cmath>#include <opencv2/opencv.hpp>enum class Color {    RED, GREEN, BLUE, INVALID};enum class Step {    LEFT, RIGHT, UP, DOWN};int rgbToInt(const cv::Vec3b& vecBgr) {    int rgb = vecBgr[2];    rgb = (rgb << 8) + vecBgr[1];    rgb = (rgb << 8) + vecBgr[0];    return rgb;}Color getCircleColor(const cv::Mat& img, const cv::Vec3f circle) {    Color color;    int x = (int) round(circle[0]);    int y = (int) round(circle[1]);    int r = (int) round(circle[2]);    std::map<int, int> count;    for (int ix = 0; ix < img.cols; ++ix)        for (int iy = 0; iy < img.rows; ++iy) {            if (std::pow(ix - x, 2) + std::pow(iy - y, 2) < std::pow(r, 2)) {                int rgb = rgbToInt(img.at<cv::Vec3b>(iy, ix));                ++count[rgb];            }        }    int max = std::max_element(count.begin(), count.end(),                     [] (const auto& a, const auto& b) {                         return a.second < b.second;                     })->first;    const int RED = 0xFF0000;    const int GREEN = 0x00FF00;    const int BLUE = 0x0000FF;    switch (max) {        case RED:            color = Color::RED;            break;        case GREEN:            color = Color::GREEN;            break;        case BLUE:            color = Color::BLUE;            break;        default:            color = Color::INVALID;            break;    }    return color;}void step(const Step& s, cv::Point& p) {    switch (s) {        case Step::LEFT:            --p.x;            break;        case Step::RIGHT:            ++p.x;            break;        case Step::UP:            --p.y;            break;        case Step::DOWN:            ++p.y;            break;    }}void turnRight(Step& s) {    switch (s) {        case Step::LEFT:            s = Step::UP;            break;        case Step::RIGHT:            s = Step::DOWN;            break;        case Step::UP:            s = Step::RIGHT;            break;        case Step::DOWN:            s = Step::LEFT;            break;    }}Step reversedStep(const Step& s) {    switch (s) {        case Step::LEFT:            return Step::RIGHT;        case Step::RIGHT:            return Step::LEFT;        case Step::UP:            return Step::DOWN;        case Step::DOWN:            return Step::UP;    }}cv::Point getLeftPoint(const cv::Point& p, const Step& s) {    switch (s) {        case Step::LEFT:            return cv::Point(p.x, p.y + 1);        case Step::RIGHT:            return cv::Point(p.x, p.y - 1);        case Step::UP:            return cv::Point(p.x - 1, p.y);        case Step::DOWN:            return cv::Point(p.x + 1, p.y);    }}inline bool isExit(const cv::Point& p, const cv::Point& end) {    return (p.y == end.y && std::abs(p.x - end.x) < 50 ||            p.x == end.x && std::abs(p.y - end.y) < 50);}void solveMaze(cv::Mat& img, const cv::Point& begin, const cv::Point& end) {    auto current = begin;    cv::Vec3b white;    white.val[0] = white.val[1] = white.val[2] = 0xFF;    auto s = Step::DOWN;    std::vector<cv::Point> path;    while (img.at<cv::Vec3b>(current) != white) {        path.push_back(current);        step(s, current);    }    step(reversedStep(s), current);    turnRight(s);    while (true) {        while (img.at<cv::Vec3b>(current) != white) {            if (img.at<cv::Vec3b>(getLeftPoint(current, s)) != white) {                turnRight(s);                s = reversedStep(s);            }            path.push_back(current);            step(s, current);            if (isExit(current, end)) break;        }        if (isExit(current, end)) break;        step(reversedStep(s), current);        turnRight(s);    }    auto blue = cv::Scalar(255,0,0);    size_t i;    for (i = 0; i < path.size() - 1; ++i) {        cv::line(img, path[i], path[i + 1], blue, 3);    }    cv::line(img, path[i], end, cv::Scalar(255,0,0), 3);    cv::imshow("maze", img);    cv::waitKey();}int main(int argc, char* argv[]) {    const std::string file = "/home/vladislav/sem3/circles/Labyrinth_3.png";    auto img = cv::imread(file);    cv::Mat gimg;    cv::cvtColor(img, gimg, cv::COLOR_BGR2GRAY);    std::vector<cv::Vec3f> circles;    cv::HoughCircles(gimg, circles, cv::HOUGH_GRADIENT, 1, 90, 50, 20, 0, 150);    cv::Point begin, end;    for (const auto& i : circles) {        auto color = getCircleColor(img, i);        switch (color) {            case Color::RED:                end.x = (int)i.val[0];                end.y = (int)i.val[1];                break;            case Color::GREEN:                begin.x = (int)i.val[0];                begin.y = (int)i.val[1];                break;            case Color::BLUE:break;            case Color::INVALID:break;        }    }    solveMaze(img, begin, end);    return 0;}